---
title: "QTW - Case Study RTLS"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Libraries used for this analysis

```{r}
library(ggplot2)
library(lattice)

```



Functions needed by readData

```{r}
# split each line on ; = , and return 1 line each for each observed signal (redundant time, mac, x, y, z, orientation)
processLine =
function(x)
{
  tokens = strsplit(x, "[;=,]")[[1]]
  
  if (length(tokens) == 10) #added to fix those observations where no signal detected 
    return(NULL)
  
  tmp = matrix(tokens[ - (1:10) ], ncol = 4, byrow = TRUE)
  cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow = nrow(tmp), ncol = 6, byrow = TRUE), tmp)
}

# set angles to proper increments
roundOrientation = function(angles) {
  refs = seq(0, by = 45, length  = 9)
  q = sapply(angles, function(o) which.min(abs(o - refs)))
  c(refs[1:8], 0)[q]
}


```

Main data load function for first format

```{r}
readData = function(filename){
  # load data, drop all comment rows (beginning with '#')
  txt = readLines(filename) 
  lines = txt[ substr(txt, 1, 1) != "#" ] # remove lines that start with #, comments
  
  # process each line via process line function, combine all matrices that are returned
  tmp = lapply(lines, processLine)
  output = as.data.frame(do.call("rbind", tmp), stringsAsFactors = FALSE)
  
  # set column names and numeric data types
  names(output) = c("time", "scanMac", "posX", "posY", "posZ", "orientation", "mac", "signal", "channel", "type")
  numVars = c("time", "posX", "posY", "posZ", "orientation", "signal")
  output[ numVars ] =  lapply(output[ numVars ], as.numeric)

  # remove rows that aren't type == 3, drop the type column
  output = output[ output$type == "3", ]
  output = output[ , "type" != names(output) ]

  # copy raw time, convert time from ms, set proper time data types
  output$rawTime = output$time
  output$time = output$time/1000
  class(output$time) = c("POSIXt", "POSIXct")

  # convert character variables to factors
  sapply(output[ , c("mac", "channel", "scanMac")], as.factor)
  
  # drop scanmac and posZ
  output = output[ , !(names(output) %in% c("scanMac", "posZ"))]
  
  # set angles to proper rounded increments
  output$angle = roundOrientation(output$orientation)
  
  # drop all rows that aren't in the top 7 MACs by count...(this is the subMacs component from the book)
  subMacs = names(sort(table(output$mac), decreasing = TRUE))[1:7]
  output = output[ output$mac %in% subMacs, ]
  
  return(output)
  
}
```



```{r}
offline = readData("http://rdatasciencecases.org/Data/offline.final.trace.txt")
##lets look at the head of the data
head(offline)
```







<!-- ```{r} -->
<!-- # code to create offline summary -->
<!-- processOfflineSummary = function(offline){ -->
<!--   offline$posXY = paste(offline$posX, offline$posY, sep = "-") -->
<!--   byLocAngleAP = with(offline,  -->
<!--                     by(offline, list(posXY, angle, mac), function(x) x)) -->
<!--   signalSummary =  -->
<!--     lapply(byLocAngleAP,             -->
<!--          function(oneLoc) { -->
<!--            ans = oneLoc[1, ] -->
<!--            ans$medSignal = median(oneLoc$signal) -->
<!--            ans$avgSignal = mean(oneLoc$signal) -->
<!--            ans$num = length(oneLoc$signal) -->
<!--            ans$sdSignal = sd(oneLoc$signal) -->
<!--            ans$iqrSignal = IQR(oneLoc$signal) -->
<!--            ans -->
<!--            }) -->
<!--   return(do.call("rbind", signalSummary)) -->
<!-- } -->

<!-- ``` -->

<!-- ```{r} -->
<!-- offlineSummary = processOfflineSummary(offline) -->
<!-- ``` -->

```{r}
online = readData("online.final.txt")
```

```{r}
# code to create online summary
processOnlineSummary = function(online){
  online$posXY = paste(online$posX, online$posY, sep="-") # create new feature combining posX with posY for each row
  online$posXY <- factor(online$posXY) #let's make posXY a factor THIS IS WHAT WAS MISSING IN THE BOOK!

  keepVars = c("posXY", "posX","posY", "orientation", "angle")
  byLoc = with(online, # with applies an expression to the dataset "with(data, expression)", in this case applies "by"
    by(online, list(posXY),  # by applies a function to each level of a factor "by(data, factorlist, function)"
      function(x) {
        ans = x[1, keepVars]
        avgSS = tapply(x$signal, x$mac, mean)
        y = matrix(avgSS, nrow = 1, ncol = 7, dimnames = list(ans$posXY, names(avgSS)))  # THIS NEEDS TO BE 7 COL, NOT 6 LIKE THE BOOK..BECAUSE WE HAVEN'T DROPPED EXTRA MAC YET
        cbind(ans, y)
        }))

  return(onlineSummary = do.call("rbind", byLoc))
}
```

```{r}
onlineSummary = processOnlineSummary(online)
```


```{r}
reshapeSS = function(data, varSignal = "signal", keepVars = c("posXY", "posX","posY")) {
  data$posXY = factor(data$posXY) ## added this here as well, since it needs to be a factor for the by function below
  byLocation =
    with(data, by(data, list(posXY),
                  function(x) {
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 7, dimnames = list(ans$posXY, names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

```


```{r}
selectTrain = function(angleNewObs, signals = NULL, m = 1){   # m is the number of angles to keep between 1 and 5

  refs = seq(0, by = 45, length  = 8)
  nearestAngle = roundOrientation(angleNewObs)

  if (m %% 2 == 1)
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
  else {
    m = m + 1
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
    if (sign(angleNewObs - nearestAngle) > -1)
      angles = angles[ -1 ]
    else
      angles = angles[ -m ]
  }
  angles = angles + nearestAngle
  angles[angles < 0] = angles[ angles < 0 ] + 360
  angles[angles > 360] = angles[ angles > 360 ] - 360
  angles = sort(angles)

  offlineSubset = signals[ signals$angle %in% angles, ]
  return(reshapeSS(offlineSubset, varSignal = "avgSignal"))
}

```



<!-- ```{r} -->
<!-- findNN = function(newSignal, trainSubset) { -->
<!--   diffs = apply(trainSubset[ , 4:9], 1, function(x) x - newSignal) # this returns a list of data frames - DOESN'T WORK FROM THE BOOK -->
<!--   diffs = do.call("rbind", diffs) # converts diffs into a single data frame -->
<!--   diffs = as.matrix(diffs) # converts dataframe to a matrix -->
<!--   dists = apply(diffs, 2, function(x) sqrt(sum(x^2))) # for each row of diffs, square the distance for each, add together, take square root -->
<!--   closest = order(dists) -->
<!--   return(trainSubset[closest, 1:3 ]) -->
<!-- } -->

<!-- ``` -->



<!-- ```{r} -->
<!-- # code to drop extra MAC...need to be careful where we do this or the  -->

<!-- #offlineSummary = offlineSummary[offlineSummary$mac != '00:0f:a3:39:dd:cd',] # drop rows containing the extra MAC -->
<!-- #onlineSummary = onlineSummary[, !(names(onlineSummary) %in% '00:0f:a3:39:dd:cd')] # drop column containing the extra MAC -->

<!-- ``` -->


<!-- ```{r} -->
<!-- # create a training set with angle 90 and (45,90,135 in the whole set) -->
<!-- train90 = selectTrain(90, offlineSummary, m = 3) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- # Create some testing observations with angle == 90 -->

<!-- temp90 = onlineSummary[onlineSummary$angle == 90, ] -->
<!-- temp90 = temp90[,6:11] -->

<!-- ``` -->

<!-- ```{r} -->

<!-- train90 = train90[, !(names(train90) %in% '00:0f:a3:39:dd:cd')] -->

<!-- # working -->

<!-- diffs = apply(train90[, 4:9], 1, function(x) x - temp90[1,])  # create diffs, which creates a list of data frames -->
<!-- diffs = do.call("rbind", diffs) # converts diffs into a single data frame -->
<!-- diffs = as.matrix(diffs) -->





<!-- ``` -->







